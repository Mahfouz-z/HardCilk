package sysGen

import chisel3._
import chisel3.util._

import axis4._
import stealSide._
import continuationSide._
import argRouting._
import commonInterfaces._
import axi4.full.readyValidMem



// task width includes a 64 bit counter at its start

class sysGenHDL( sysAddressWidth : Int,
                 taskWidth : Int,
                 peCount : Int,
                 stealQueueLength : Int,
                 contQueueLength : Int,
                 argQueueLength : Int,
                 argRouteServersNumber : Int,
                 noContinuations : Boolean,
                 contCounterWidth : Int
                ) extends Module {
    

    implicit val axisCfgTask    = Config(wData = taskWidth, onlyRV = true)
    implicit val axisCfgAddress = Config(wData = sysAddressWidth, onlyRV = true)


    // Instantiate the IOs
    val io = IO(new Bundle {
        val taskOut    = Vec(peCount, axis4.Master(axisCfgTask))
        val taskIn     = Vec(peCount, axis4.Slave(axisCfgTask))
        val contOut    = Vec(peCount, axis4.Master(axisCfgAddress))
        val addrIn     = Vec(peCount, axis4.Slave(axisCfgAddress))
    })



    ////////////////////////////////////////////////////////////////////////////////
    // Steal Side Instantiations
    val stealSide = Module(new stealNW_TQ( peCount = peCount,
                                vasCount = argRouteServersNumber,
                                taskWidth = taskWidth, 
                                queueMaxLength = stealQueueLength, 
                                qRamReadLatency = 1, 
                                qRamWriteLatency = 2)
                                )

    val vss0 = Module(new virtualStealServer( taskWidth = taskWidth, 
                                              contentionThreshold = ((peCount+argRouteServersNumber)/1.2).toInt,
                                              peCount = peCount,
                                              contentionDelta = 0,
                                              vasCount = argRouteServersNumber,
                                              sysAddressWidth = sysAddressWidth)
                                              )
    
    val axi_mgmt_vss = IO(axi4.Slave(vss0.regBlock.axiConfig))
    axi_mgmt_vss <> vss0.io.axi_mgmt
    vss0.io.ntwDataUnitOccupancy <> stealSide.io.ntwDataUnitOccupancyVSS

    val vssAxiFullCfg = axi4.Config(
                wAddr = sysAddressWidth,
                wData = taskWidth,
                lite = false
            )
    val vss_axi_full = IO(axi4.Master(vssAxiFullCfg))
    val vssRvm       = Module(new readyValidMem(taskWidth, sysAddressWidth))
    
    vssRvm.io.read.get.address  <> vss0.io.read_address
    vssRvm.io.read.get.data     <> vss0.io.read_data
    vssRvm.io.write.get.address <> vss0.io.write_address
    vssRvm.io.write.get.data    <> vss0.io.write_data
    vssRvm.axi                  <> vss_axi_full 
    vss0.io.connNetwork         <> stealSide.io.connVSS

    for(i <- 0 until peCount){
        stealSide.io.connPE(i).pop   <> io.taskOut(i).lite
        stealSide.io.connPE(i).push  <> io.taskIn(i).lite
    }
    
    ////////////////////////////////////////////////////////////////////////////////
    // Continuation Side Instantiations
    val contSide = Module(new contNetwork( addrWidth  = sysAddressWidth,
                                           peCount    = peCount,
                                           queueDepth = contQueueLength)
                                           )
    
    val vcas0 = Module(new virtContAddrServer( dataWidth = sysAddressWidth,
                                               sysAddressWidth = sysAddressWidth)
                                               )

    val axi_mgmt_vcas = IO(axi4.Slave(vcas0.regBlock.axiConfig))
    axi_mgmt_vcas <> vcas0.io.axi_mgmt

    val vcasAxiFullCfg = axi4.Config(
            wAddr = sysAddressWidth,
            wData = sysAddressWidth,
            lite = false
        )

    val vcas_axi_full = IO(axi4.Master(vcasAxiFullCfg))
    val vcasRvmRO     = Module(new readyValidMem(sysAddressWidth, sysAddressWidth, write=false))


    vcasRvmRO.io.read.get.address  <> vcas0.io.read_address
    vcasRvmRO.io.read.get.data     <> vcas0.io.read_data
    vcasRvmRO.axi                  <> vcas_axi_full
    vcas0.io.dataOut               <> contSide.io.connVCAS

    for(i <- 0 until peCount){
        contSide.io.connPE(i) <> io.contOut(i).lite
    }

    ///////////////////////////////////////////////////////////////////////////////

    

    val argSide = Module(new argRouteNetwork( addrWidth = sysAddressWidth,
                                              taskWidth = taskWidth, 
                                              peCount = peCount,
                                              vasNum = argRouteServersNumber,
                                              queueDepth = argQueueLength)
                                         )

    val serversList       = List.tabulate(argRouteServersNumber)(n => n)
    val argRouteServers = serversList.zipWithIndex.map { case (tag, index) =>
        Module(new argRouteVirtServerV2( 
                                    taskWidth = taskWidth,
                                    counterWidth = contCounterWidth,
                                    sysAddressWidth = sysAddressWidth, 
                                    tagBitsShift = log2Ceil(taskWidth/8),
                                    noContinuations = noContinuations
                                    ))
        }



    val addrServerAxiFullCfg = axi4.Config(
        wAddr = sysAddressWidth,
        wData = sysAddressWidth,
        lite = false
    )
    val argRouteAxiFullCfg = axi4.Config(
        wAddr = sysAddressWidth,
        wData = contCounterWidth,
        lite = false
    )
    val axi_full_argRoute = Seq.fill(argRouteServersNumber)(IO(axi4.Master(argRouteAxiFullCfg)))
    val argRouteRvm       = Seq.fill(argRouteServersNumber)(Module(new readyValidMem(contCounterWidth, sysAddressWidth)))

    for(i <- 0 until argRouteServersNumber){
        
        axi_full_argRoute(i)                <> argRouteRvm(i).axi
        argRouteRvm(i).io.read.get.address  <> argRouteServers(i).io.read_address
        argRouteRvm(i).io.read.get.data     <> argRouteServers(i).io.read_data
        argRouteRvm(i).io.write.get.address <> argRouteServers(i).io.write_address
        argRouteRvm(i).io.write.get.data    <> argRouteServers(i).io.write_data
        argRouteServers(i).io.connNetwork   <> argSide.io.connVAS(i)
        argRouteServers(i).io.connStealNtw  <> stealSide.io.connVAS(i)  
    }       

    for(i <- 0 until peCount){
        argSide.io.connPE(i) <> io.addrIn(i).lite
    }                         
    
    ////////////////////////////////////////////////////////////////////////////////
    vss0.regBlock.saveRegisterMap("output", "vss0.registers")
    vcas0.regBlock.saveRegisterMap("output", "vcas0.registers")
}